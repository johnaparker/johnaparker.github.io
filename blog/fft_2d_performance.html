<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.1 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>FFT performance using NumPy, PyFFTW, and cuFFT - John Parker</title>
<meta name="description" content="Compare the performance of different FFT implementations, using Python">


  <meta name="author" content="John Parker, PhD">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="John Parker">
<meta property="og:title" content="FFT performance using NumPy, PyFFTW, and cuFFT">
<meta property="og:url" content="https:://johnaparker.github.io/blog/fft_2d_performance">


  <meta property="og:description" content="Compare the performance of different FFT implementations, using Python">







  <meta property="article:published_time" content="2020-10-14T00:00:00-05:00">





  

  


<link rel="canonical" href="https:://johnaparker.github.io/blog/fft_2d_performance">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "John Parker",
      "url": "https:://johnaparker.github.io/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="John Parker Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



<link rel='stylesheet' href='//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack-subset.css'>

<script type="text/javascript">
window.MathJax = {
  tex: {
    packages: ['base', 'ams']
  },
  loader: {
    load: ['ui/menu', '[tex]/ams']
  }
};
</script>

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
           
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/projects/">Projects</a>
            </li><li class="masthead__menu-item">
              <a href="/research/">Research</a>
            </li><li class="masthead__menu-item">
              <a href="/publications/">Publications</a>
            </li><li class="masthead__menu-item">
              <a href="/presentations/">Presentations</a>
            </li><li class="masthead__menu-item">
              <a href="/blog/">Blog</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/img/john_avatar.png" alt="John Parker, PhD" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">John Parker, PhD</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Computational scientist</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Info</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Chicago</span>
        </li>
      

      
        
          
            <li><a href="https://github.com/johnaparker" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="https://scholar.google.com/citations?user=1CwIyOUAAAAJ&hl=en" rel="nofollow noopener noreferrer"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span class="label">Scholar</span></a></li>
          
        
      

      

      
        <li>
          <a href="mailto:john7494@gmail.com">
            <meta itemprop="email" content="john7494@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="FFT performance using NumPy, PyFFTW, and cuFFT">
    <meta itemprop="description" content="Compare the performance of different FFT implementations, using Python">
    <meta itemprop="datePublished" content="2020-10-14T00:00:00-05:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">FFT performance using NumPy, PyFFTW, and cuFFT
</h1>
          


  <p class="page__meta">

    
      
      <i class="far fa-calendar-alt" aria-hidden="true"></i>
      <time datetime="2020-10-14T00:00:00-05:00">October 14, 2020</time>
    

    
      
      <span class="post__meta-sep"></span>
      
    


    
    <i class="fab fa-fw fab fa-github"></i> <a href=https://github.com/johnaparker/blog/tree/master/fft_performance>View Code</a>
    

  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-bars"></i>  Contents</h4></header>
              <ul class="toc__menu">
  <li><a href="#problem-statement">Problem statement</a></li>
  <li><a href="#hardware">Hardware</a></li>
  <li><a href="#measuring-runtime-performance">Measuring runtime performance</a></li>
  <li><a href="#numpy-implementation">NumPy implementation</a></li>
  <li><a href="#pyfftw-implementation">PyFFTW implementation</a></li>
  <li><a href="#cufft-implementation">cuFFT implementation</a></li>
  <li><a href="#performance-comparison">Performance comparison</a></li>
</ul>

            </nav>
          </aside>
        
        <h2 id="problem-statement">Problem statement</h2>
<p>Suppose we want to calculate the fast Fourier transform (FFT) of a two-dimensional image, and we want to make the call in Python and receive the result in a NumPy array.
The easy way to do this is to utilize NumPy’s <a href="https://numpy.org/doc/stable/reference/routines.fft.html">FFT library</a>.
Now suppose that we need to calculate many FFTs and we care about performance.
Is NumPy’s FFT algorithm the most efficient?
NumPy doesn’t use <a href="http://www.fftw.org">FFTW</a>, widely regarded as the fastest implementation.
The <a href="https://github.com/pyFFTW/pyFFTW">PyFFTW</a> library was written to address this omission. 
FFTs are also efficiently evaluated on GPUs, and the CUDA runtime library <a href="https://developer.nvidia.com/cufft">cuFFT</a> can be used to calculate FFTs.</p>

<p>For the 2D image, we will use random data of size <code class="language-plaintext highlighter-rouge">n × n</code> with 32 bit floating point precision</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)).</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div></div>
<p>We would like to compare the performance of three different FFT implementations at different image sizes <code class="language-plaintext highlighter-rouge">n</code>.</p>

<h2 id="hardware">Hardware</h2>

<p>The relative performance of the CPU and GPU implementations will depend on the hardware being using. 
This is the hardware I’m using to produce the results in this post:</p>

<table>
  <tbody>
    <tr>
      <td><strong>CPU</strong></td>
      <td>AMD Ryzen 2700X (8 core, 16 thread, 3.7 GHz)</td>
    </tr>
    <tr>
      <td><strong>GPU</strong></td>
      <td>NVIDIA RTX 2070 Super (2560 CUDA cores, 1.6 Ghz)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="measuring-runtime-performance">Measuring runtime performance</h2>
<p>To measure the runtime performance of a function, we will define <code class="language-plaintext highlighter-rouge">time_function</code> that calls the function many times, similar to IPython’s <code class="language-plaintext highlighter-rouge">timeit</code>.
The <code class="language-plaintext highlighter-rouge">time_function</code> is written such that it will not run longer than 0.1 seconds or the runtime of a single function call.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">time_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="p">.</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Time a function by running it repeatedly for at least 'runtime' seconds"""</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">runtime</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="n">tf</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">+=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>

        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="n">count</span>
</code></pre></div></div>

<h2 id="numpy-implementation">NumPy implementation</h2>
<p>In NumPy, we can use <code class="language-plaintext highlighter-rouge">np.fft.rfft2</code> to compute the real-valued 2D FFT of the image:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numpy_fft</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">fft</span><span class="p">.</span><span class="n">rfft2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
<span class="n">numpy_time</span> <span class="o">=</span> <span class="n">time_function</span><span class="p">(</span><span class="n">numpy_fft</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span>  <span class="c1"># in ms
</span></code></pre></div></div>
<p>This measures the runtime in milliseconds. 
This can be repeated for different image sizes, and we will plot the runtime at the end.</p>

<h2 id="pyfftw-implementation">PyFFTW implementation</h2>
<p>In PyFFTW, we have to create <code class="language-plaintext highlighter-rouge">pyFFTW.empty_aligned</code> arrays to store the image and the FFT output.
The FFT is performed by calling <code class="language-plaintext highlighter-rouge">pyfftw.FFTW</code> on these arrays, and the number of threads can also be specified here (I choose 16 in my case):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">### Prepare the image for PyFFTW
</span><span class="n">a</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="p">.</span><span class="n">empty_aligned</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'float32'</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="p">.</span><span class="n">empty_aligned</span><span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>  <span class="n">dtype</span><span class="o">=</span><span class="s">'complex64'</span><span class="p">)</span>
<span class="n">a</span><span class="p">[...]</span> <span class="o">=</span> <span class="n">image</span>
<span class="n">fft_object</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="p">.</span><span class="n">FFTW</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">threads</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>  <span class="c1"># specify number of CPU threads to use
</span>
<span class="n">pyfftw_time</span> <span class="o">=</span> <span class="n">time_function</span><span class="p">(</span><span class="n">fft_object</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span>  <span class="c1"># in ms
</span></code></pre></div></div>

<h2 id="cufft-implementation">cuFFT implementation</h2>
<p>Finally, we can compute the FFT on the GPU.
This can be done entirely with the CUDA runtime library and the <code class="language-plaintext highlighter-rouge">cufft</code> library.
In C++, the we can write the function <code class="language-plaintext highlighter-rouge">gpu_fft</code> to perform the FFT:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">gpu_fft</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">dataH</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">dataW</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/** 
    * @param dataH image height
    * @param dataW image width
    * @param iterations number of FFT iterations
    **/</span> 

    <span class="c1">// prepare the data</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">h_Data</span><span class="p">;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">d_Data</span><span class="p">;</span>
    <span class="n">cuComplex</span> <span class="o">*</span><span class="n">d_DataSpectrum</span><span class="p">;</span>

    <span class="n">h_Data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">dataH</span><span class="o">*</span><span class="n">dataW</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_Data</span><span class="p">,</span> <span class="n">dataH</span><span class="o">*</span><span class="n">dataW</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">cudaMalloc</span><span class="p">((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d_DataSpectrum</span><span class="p">,</span>   <span class="n">dataH</span> <span class="o">*</span> <span class="p">(</span><span class="n">dataW</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cuComplex</span><span class="p">));</span>

    <span class="c1">// generate random image</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dataH</span> <span class="o">*</span> <span class="n">dataW</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">h_Data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">getRand</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_Data</span><span class="p">,</span> <span class="n">h_Data</span><span class="p">,</span>   <span class="n">dataH</span><span class="o">*</span><span class="n">dataW</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

    <span class="c1">// create cuFFT plan</span>
    <span class="n">cufftHandle</span> <span class="n">fftPlanFwd</span><span class="p">;</span>
    <span class="n">cufftPlan2d</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fftPlanFwd</span><span class="p">,</span> <span class="n">dataH</span><span class="p">,</span> <span class="n">dataW</span><span class="p">,</span> <span class="n">CUFFT_R2C</span><span class="p">);</span>

    <span class="c1">// compute iterations of FFT</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iterations</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cufftExecR2C</span><span class="p">(</span><span class="n">fftPlanFwd</span><span class="p">,</span> <span class="p">(</span><span class="n">cufftReal</span> <span class="o">*</span><span class="p">)</span><span class="n">d_Data</span><span class="p">,</span> <span class="p">(</span><span class="n">cufftComplex</span> <span class="o">*</span><span class="p">)</span><span class="n">d_DataSpectrum</span><span class="p">);</span>
        <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// free data</span>
    <span class="n">free</span><span class="p">(</span><span class="n">h_Data</span><span class="p">);</span>
    <span class="n">cufftDestroy</span><span class="p">(</span><span class="n">fftPlanFwd</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_Data</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_DataSpectrum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Notice that here we pass in the width and height of the image, and generate the random image in C++. 
That data is then transferred to the GPU.
The <code class="language-plaintext highlighter-rouge">iterations</code> parameters specifies the number of times we perform the exact same FFT (to measure runtime).
Note that in doing so we are not copying the image from CPU (host) to GPU (device) at each iteration, so the performance measurement does not include the time to copy the image.
Depending on the application, the performance of <code class="language-plaintext highlighter-rouge">cudaMemcpy</code> may be critical.</p>

<p>This C++ function can be easily exposed to Python using <code class="language-plaintext highlighter-rouge">pybind11</code> with the following code:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">fft</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"gpu_fft"</span><span class="p">,</span> <span class="n">gpu_fft</span><span class="p">,</span> <span class="s">"dataH"</span><span class="n">_a</span><span class="p">,</span> <span class="s">"dataW"</span><span class="n">_a</span><span class="p">,</span> <span class="s">"iterations"</span><span class="n">_a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>The full code is available on <a href="https://github.com/johnaparker/blog/tree/master/fft_performance/fft.cpp">GitHub</a>.</p>

<p>Then we can measure the performance of this GPU implementation using the <code class="language-plaintext highlighter-rouge">time_function</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iterations</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">cuda_fft</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">gpu_fft</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">iterations</span><span class="p">)</span>
<span class="n">cuda_time</span> <span class="o">=</span> <span class="n">time_function</span><span class="p">(</span><span class="n">cuda_fft</span><span class="p">)</span><span class="o">*</span><span class="mf">1e3</span><span class="o">/</span><span class="n">iterations</span>  <span class="c1"># in ms
</span></code></pre></div></div>
<p>Here, I chose 10,000 iterations of the FFT, so that <code class="language-plaintext highlighter-rouge">cudaMemcpy</code> only runs for every 10,000 iterations.
If you choose <code class="language-plaintext highlighter-rouge">iterations=1</code>, the measured runtime would include memory allocation and deallocation, which may not be needed depending on your application.</p>

<h2 id="performance-comparison">Performance comparison</h2>
<p>With all of the functions defined, we can time them at different image sizes <code class="language-plaintext highlighter-rouge">n</code>:</p>
<figure style="width: 100%; max-width: 100%" class="align-center">
  <img src="/assets/img/posts/fft_performance/fft_benchmark.svg" alt="" />
</figure>
<p>The results on the left show the runtime for each function on a log-log scale.
We can see that for all but the smallest of image sizes, <code class="language-plaintext highlighter-rouge">cuFFT &gt; PyFFTW &gt; NumPy</code>.
On the right is the speed increase of the cuFFT implementation relative to the NumPy and PyFFTW implementations.
For the largest images, cuFFT is an order of magnitude faster than PyFFTW and two orders of magnitude faster than NumPy.</p>

        
      </section>

      <footer class="page__meta">
        
        
  <hr>
  


  
  
  

  <p class="page__taxonomy">
  <strong><i class="fab fa-github" aria-hidden="true"></i> <a href="https://github.com/johnaparker/blog/tree/master/fft_performance">View Code</a></strong>
  </p>





  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#cuda" class="page__taxonomy-item" rel="tag">CUDA</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#performance" class="page__taxonomy-item" rel="tag">Performance</a>
    
    </span>
  </p>






        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-10-14T00:00:00-05:00">October 14, 2020</time></p>


      </footer>

      

    </div>

    
  </article>

  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-copyright">&copy; 2021 John Parker. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
